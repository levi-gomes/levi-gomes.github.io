{"pageProps":{"frontmatter":{"title":"Setting up the project: Physics Engine Tutorial 0","date":"31/3/2023","cover_image":"images/posts/physics/sim0_cover.png","tags":["physics","simulation","tutorial"],"excerpt":"We'll start working on a physics engine to explore the wonderfull world of dynamics and mechanics!"},"slug":"physics_sim0","content":"\nFor the last few months, I've been writing almost exclusively about my game. I'm still working on it, and I'll be posting more devlogs, but I also want to write about other stuff. So this will be the first in a series of tutorials about making a physics engine from scratch with C#. Why? Because I like physics. So without further ado, let's get started.\n\n## Creating the project and making the visualisation\nBefore we start making a physics simulation, we need some way to view what the simulation is computing. For the sake of simplicity, I'll use [Raylib](https://www.raylib.com/index.html), and it's [C# bindings](https://github.com/ChrisDill/Raylib-cs). It's very easy to pick up (I hadn't ever used it, but I found my way around it in less than a day) and its simplicity will allow us to focus oon the physics. Furthermore, I'll be using Visual Studio to do the coding, so the process I'll describe for installing the library will be for Visual Studio.\n\nFirst, I created a new C# project. To get a clean slate, I chose a Console App. I named the solution PhysicsSim and the project PhysicsSimTester, but you can choose other names. Then I added another project to the solution, specifically a class library, named PhysicsSim. The class library will be the actual physics simulator, while the console app will only use it, in order to allow us to test our physics code. From now on, I'll refer to the class library as the *'library'* and to the console app as the *'tester'* We'll be starting by making a particle based engine, and then upgrade it to handle rigidbodies. So let's add a new class called ``Particle`` to the library. For now, I'll leave it blank. We'll come back to it later, I only added it this soon so we can prepare a skeleton for the testing code. That way, I can get it out of the way early, and then focus on implementing the physics.\n\nNow we need to install the ``raylib-cs`` NuGet package. If you don't know how to install a NuGet package, search it up. Also, we'll have to add a reference to the library in the tester. With this out of the way, we can start coding. Let's open up the autogenerated Program.cs in the tester. At the top we'll add references to Raylib, the physics library and to the tester namespace\n```cs showLineNumbers\nusing Raylib_cs;\nusing PhysicsSim;\nusing PhysicsSimTester;\n```\n\nInside the ``Main`` function, we'll write the following code:\n```cs showLineNumbers\nprivate static void Main(string[] args) \n        // Initialize Raylib\n        Raylib.InitWindow(800, 800, \"Physics Sim\");\n        Raylib.SetTraceLogLevel(TraceLogLevel.LOG_ALL);\n        Raylib.SetTargetFPS(200);\n        \n        // Core loop\n        while(!Raylib.WindowShouldClose()) {\n            Raylib.BeginDrawing();\n            Raylib.ClearBackground(Color.BLACK);\n            Raylib.DrawCircle(400, 400, 100, Color.WHITE);\n            Raylib.EndDrawing();\n        }\n\n        Raylib.CloseWindow();\n    }\n```\n\nFirst, we open a 800 by 800 window, tell Raylib to log everything and set the framerate to 200. Then we loop until Raylib tells us we should close the window. Every frame, we prepare for drawing, clear the canvas, draw a circle and send out the new frame. If you run this code, you should get something like fig. 1.\n&&&img[images/posts/physics/raylib_helloworld.png](Figure 1) A simple Raylib program.\n&&&\n\nNext we'll add a ``Visualisation`` class. This will be what actually draws things to the screen in the final program.\n```cs showLineNumbers\nusing PhysicsSim;\nusing Raylib_cs;\n\nnamespace PhysicsSimTester\n{\n    public static class Visualization\n    {\n        public static int Res;\n        public static int TextUnits { get => Res / 100; }\n        public static Font font;\n\n        // Variables used for the debug interface\n        private struct SmoothDebugFloat {\n            private const int cacheMax = 64;\n            private int currentIndex;\n            private float[] cachedValues;\n            private float sum;\n            public float AverageValue { get => sum / cacheMax; }\n\n            public SmoothDebugFloat() {\n                currentIndex = 0;\n                cachedValues = new float[cacheMax];\n                sum = 0;\n            }\n            public void FeedValue(float value) {\n                sum -= cachedValues[currentIndex];\n                sum += value;\n                cachedValues[currentIndex] = value;\n                currentIndex = (currentIndex + 1) % cacheMax;\n            }\n        }\n        private static SmoothDebugFloat deltaTime;\n\n        \n        public static void Init(int res) {\n            // Set the resolution\n            Res = res;\n\n            // Initialize Raylib\n            Raylib.InitWindow(Res, Res, \"Physics Sim\");\n            Raylib.SetTraceLogLevel(TraceLogLevel.LOG_ALL);\n            Raylib.SetTargetFPS(200);\n            // Load a better font\n            font = Raylib.LoadFontEx(\"times.ttf\", 256, null, 1024);\n\n            deltaTime = new SmoothDebugFloat();\n        }\n\n        public static void DrawAll(params Particle[] objects) {\n            foreach (var obj in objects) {\n                Draw(obj);\n            }\n        }\n        public static void Draw(Particle obj) {\n            \n        }\n\n        public static void DrawDebugInterface(float dt) {\n            // Feed the delta time to the corresponding smooth value\n            deltaTime.FeedValue(dt);\n\n            // Write info to the screen\n            DrawDebugLine($\"{objects.Length} objects @ {(1 / deltaTime.AverageValue).ToString(\"F0\")} FPS\", 2, 2);\n            DrawDebugLine($\"{(dt*1000).ToString(\"F4\")}Î”t (in ms)\", 2, 4);\n        }\n        private static void DrawDebugLine(string line, float x, float y) {\n            Raylib.DrawTextEx(font, line, new System.Numerics.Vector2(x * ScreenUnit, y * ScreenUnit),\n                    (int)(2.6 * ScreenUnit), (int)(ScreenUnit / 3), Color.RAYWHITE);\n        }\n        private static void DrawDebugLine(string line, float x, float y, Color color) {\n            Raylib.DrawTextEx(font, line, new System.Numerics.Vector2(x * ScreenUnit, y * ScreenUnit),\n                    (int)(2.6 * ScreenUnit), (int)(ScreenUnit / 3), color);\n        }\n    }\n}\n\n```\n\nThats's a lot, so let's break it down. Firstly, we declare a few variables for convenience. Next we declare the ``SmoothDebugFloat`` struct. This struct holds a list ov previous values of *something* and computes their average. This way, values that change very fast are smoothed. As we need to write more and more debug info, this will become very usefull. For now, we're using it only for delta time. Then we initialize the visualization. We set the resolution, open a window, set the log level (what kind of info Raylib should output to the console), set the desired FPS, load a font ant initialize our delta time. Next, the ``DrawAll`` function receives a list of particles and ``Draw``s each one of them. For now, we don't actually ddraw anything. Finally, we have a function to draw some debug info to the screen.\n\nFor the font loading to work, it is necessary to have a font file in the same folder as the program. To get the file, if you're on Windows, you can go to ``C:\\Windows\\Fonts`` and search for the font family you want (for instance, I chose Times New Roman). Then open it and copy the specific font (I chose the normal one, but you could use bold or italic). Open your project's root folder and navigate to the folder where the ``.exe`` file is, and paste the font file.\n\nNow it's only a matter of calling these functions from ``Main``.\n```cs showLineNumbers\nprivate static void Main(string[] args) \n        // Init the visualization\n        Visualization.Init(800);\n        \n        // Core loop\n        while(!Raylib.WindowShouldClose()) {\n            Raylib.BeginDrawing();\n            Raylib.ClearBackground(Color.BLACK);\n            Visualization.DrawAll();\n            Visualization.DrawDebugInterface(Raylib.GetFrameTime());\n            Raylib.EndDrawing();\n        }\n\n        Raylib.CloseWindow();\n    }\n```\n\nAnd this concludes what we could call the frontend of this app. Before we start implementing the simulation itself, it's necessary to review a lot of maths and physics. So, not to make this post enormous, I'll postpone that for the next post, making this one a shorter one. I'm really excited for this project, and I hopefully so are you. Until the next time, have some fun toying around with Raylib! As a side note, I'd advise you to study some [calculus](https://youtube.com/playlist?list=PLZHQObOWTQDMsr9K-rj53DwVRMYO3t5Yr) and [linear algebra](https://youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab) while you're waiting for the next post, especially if you don't know much about these topics, because they'll be very important. And finally, you can find the source code for this project (although at a later stage) on [GitHub](https://github.com/levimcgomes/PhysicsSim)."},"__N_SSG":true}